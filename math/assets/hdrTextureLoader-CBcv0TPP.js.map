{"version":3,"file":"hdrTextureLoader-CBcv0TPP.js","sources":["../../node_modules/@babylonjs/core/Misc/HighDynamicRange/hdr.js","../../node_modules/@babylonjs/core/Materials/Textures/Loaders/hdrTextureLoader.js"],"sourcesContent":["import { PanoramaToCubeMapTools } from \"./panoramaToCubemap.js\";\n/* This groups tools to convert HDR texture to native colors array. */\nfunction ldexp(mantissa, exponent) {\n    if (exponent > 1023) {\n        return mantissa * Math.pow(2, 1023) * Math.pow(2, exponent - 1023);\n    }\n    if (exponent < -1074) {\n        return mantissa * Math.pow(2, -1074) * Math.pow(2, exponent + 1074);\n    }\n    return mantissa * Math.pow(2, exponent);\n}\nfunction rgbe2float(float32array, red, green, blue, exponent, index) {\n    if (exponent > 0) {\n        /*nonzero pixel*/\n        exponent = ldexp(1.0, exponent - (128 + 8));\n        float32array[index + 0] = red * exponent;\n        float32array[index + 1] = green * exponent;\n        float32array[index + 2] = blue * exponent;\n    }\n    else {\n        float32array[index + 0] = 0;\n        float32array[index + 1] = 0;\n        float32array[index + 2] = 0;\n    }\n}\nfunction readStringLine(uint8array, startIndex) {\n    let line = \"\";\n    let character = \"\";\n    for (let i = startIndex; i < uint8array.length - startIndex; i++) {\n        character = String.fromCharCode(uint8array[i]);\n        if (character == \"\\n\") {\n            break;\n        }\n        line += character;\n    }\n    return line;\n}\n/**\n * Reads header information from an RGBE texture stored in a native array.\n * More information on this format are available here:\n * https://en.wikipedia.org/wiki/RGBE_image_format\n *\n * @param uint8array The binary file stored in  native array.\n * @returns The header information.\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function RGBE_ReadHeader(uint8array) {\n    let height = 0;\n    let width = 0;\n    let line = readStringLine(uint8array, 0);\n    if (line[0] != \"#\" || line[1] != \"?\") {\n        // eslint-disable-next-line no-throw-literal\n        throw \"Bad HDR Format.\";\n    }\n    let endOfHeader = false;\n    let findFormat = false;\n    let lineIndex = 0;\n    do {\n        lineIndex += line.length + 1;\n        line = readStringLine(uint8array, lineIndex);\n        if (line == \"FORMAT=32-bit_rle_rgbe\") {\n            findFormat = true;\n        }\n        else if (line.length == 0) {\n            endOfHeader = true;\n        }\n    } while (!endOfHeader);\n    if (!findFormat) {\n        // eslint-disable-next-line no-throw-literal\n        throw \"HDR Bad header format, unsupported FORMAT\";\n    }\n    lineIndex += line.length + 1;\n    line = readStringLine(uint8array, lineIndex);\n    const sizeRegexp = /^-Y (.*) \\+X (.*)$/g;\n    const match = sizeRegexp.exec(line);\n    // TODO. Support +Y and -X if needed.\n    if (!match || match.length < 3) {\n        // eslint-disable-next-line no-throw-literal\n        throw \"HDR Bad header format, no size\";\n    }\n    width = parseInt(match[2]);\n    height = parseInt(match[1]);\n    if (width < 8 || width > 0x7fff) {\n        // eslint-disable-next-line no-throw-literal\n        throw \"HDR Bad header format, unsupported size\";\n    }\n    lineIndex += line.length + 1;\n    return {\n        height: height,\n        width: width,\n        dataPosition: lineIndex,\n    };\n}\n/**\n * Returns the cubemap information (each faces texture data) extracted from an RGBE texture.\n * This RGBE texture needs to store the information as a panorama.\n *\n * More information on this format are available here:\n * https://en.wikipedia.org/wiki/RGBE_image_format\n *\n * @param buffer The binary file stored in an array buffer.\n * @param size The expected size of the extracted cubemap.\n * @param supersample enable supersampling the cubemap (default: false)\n * @returns The Cube Map information.\n */\nexport function GetCubeMapTextureData(buffer, size, supersample = false) {\n    const uint8array = new Uint8Array(buffer);\n    const hdrInfo = RGBE_ReadHeader(uint8array);\n    const data = RGBE_ReadPixels(uint8array, hdrInfo);\n    const cubeMapData = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(data, hdrInfo.width, hdrInfo.height, size, supersample);\n    return cubeMapData;\n}\n/**\n * Returns the pixels data extracted from an RGBE texture.\n * This pixels will be stored left to right up to down in the R G B order in one array.\n *\n * More information on this format are available here:\n * https://en.wikipedia.org/wiki/RGBE_image_format\n *\n * @param uint8array The binary file stored in an array buffer.\n * @param hdrInfo The header information of the file.\n * @returns The pixels data in RGB right to left up to down order.\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function RGBE_ReadPixels(uint8array, hdrInfo) {\n    return readRGBEPixelsRLE(uint8array, hdrInfo);\n}\nfunction readRGBEPixelsRLE(uint8array, hdrInfo) {\n    let num_scanlines = hdrInfo.height;\n    const scanline_width = hdrInfo.width;\n    let a, b, c, d, count;\n    let dataIndex = hdrInfo.dataPosition;\n    let index = 0, endIndex = 0, i = 0;\n    const scanLineArrayBuffer = new ArrayBuffer(scanline_width * 4); // four channel R G B E\n    const scanLineArray = new Uint8Array(scanLineArrayBuffer);\n    // 3 channels of 4 bytes per pixel in float.\n    const resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);\n    const resultArray = new Float32Array(resultBuffer);\n    // read in each successive scanline\n    while (num_scanlines > 0) {\n        a = uint8array[dataIndex++];\n        b = uint8array[dataIndex++];\n        c = uint8array[dataIndex++];\n        d = uint8array[dataIndex++];\n        if (a != 2 || b != 2 || c & 0x80 || hdrInfo.width < 8 || hdrInfo.width > 32767) {\n            return readRGBEPixelsNotRLE(uint8array, hdrInfo);\n        }\n        if (((c << 8) | d) != scanline_width) {\n            // eslint-disable-next-line no-throw-literal\n            throw \"HDR Bad header format, wrong scan line width\";\n        }\n        index = 0;\n        // read each of the four channels for the scanline into the buffer\n        for (i = 0; i < 4; i++) {\n            endIndex = (i + 1) * scanline_width;\n            while (index < endIndex) {\n                a = uint8array[dataIndex++];\n                b = uint8array[dataIndex++];\n                if (a > 128) {\n                    // a run of the same value\n                    count = a - 128;\n                    if (count == 0 || count > endIndex - index) {\n                        // eslint-disable-next-line no-throw-literal\n                        throw \"HDR Bad Format, bad scanline data (run)\";\n                    }\n                    while (count-- > 0) {\n                        scanLineArray[index++] = b;\n                    }\n                }\n                else {\n                    // a non-run\n                    count = a;\n                    if (count == 0 || count > endIndex - index) {\n                        // eslint-disable-next-line no-throw-literal\n                        throw \"HDR Bad Format, bad scanline data (non-run)\";\n                    }\n                    scanLineArray[index++] = b;\n                    if (--count > 0) {\n                        for (let j = 0; j < count; j++) {\n                            scanLineArray[index++] = uint8array[dataIndex++];\n                        }\n                    }\n                }\n            }\n        }\n        // now convert data from buffer into floats\n        for (i = 0; i < scanline_width; i++) {\n            a = scanLineArray[i];\n            b = scanLineArray[i + scanline_width];\n            c = scanLineArray[i + 2 * scanline_width];\n            d = scanLineArray[i + 3 * scanline_width];\n            rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);\n        }\n        num_scanlines--;\n    }\n    return resultArray;\n}\nfunction readRGBEPixelsNotRLE(uint8array, hdrInfo) {\n    // this file is not run length encoded\n    // read values sequentially\n    let num_scanlines = hdrInfo.height;\n    const scanline_width = hdrInfo.width;\n    let a, b, c, d, i;\n    let dataIndex = hdrInfo.dataPosition;\n    // 3 channels of 4 bytes per pixel in float.\n    const resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);\n    const resultArray = new Float32Array(resultBuffer);\n    // read in each successive scanline\n    while (num_scanlines > 0) {\n        for (i = 0; i < hdrInfo.width; i++) {\n            a = uint8array[dataIndex++];\n            b = uint8array[dataIndex++];\n            c = uint8array[dataIndex++];\n            d = uint8array[dataIndex++];\n            rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);\n        }\n        num_scanlines--;\n    }\n    return resultArray;\n}\n/**\n * @deprecated Use functions separately\n */\nexport const HDRTools = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    RGBE_ReadHeader,\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    GetCubeMapTextureData,\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    RGBE_ReadPixels,\n};\n//# sourceMappingURL=hdr.js.map","import { RGBE_ReadHeader, RGBE_ReadPixels } from \"../../../Misc/HighDynamicRange/hdr.js\";\n\n/**\n * Implementation of the HDR Texture Loader.\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class _HDRTextureLoader {\n    constructor() {\n        /**\n         * Defines whether the loader supports cascade loading the different faces.\n         */\n        this.supportCascades = false;\n    }\n    /**\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\n     * Cube texture are not supported by .hdr files\n     */\n    loadCubeData() {\n        // eslint-disable-next-line no-throw-literal\n        throw \".hdr not supported in Cube.\";\n    }\n    /**\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\n     * @param data contains the texture data\n     * @param texture defines the BabylonJS internal texture\n     * @param callback defines the method to call once ready to upload\n     */\n    loadData(data, texture, callback) {\n        const uint8array = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n        const hdrInfo = RGBE_ReadHeader(uint8array);\n        const pixelsDataRGB32 = RGBE_ReadPixels(uint8array, hdrInfo);\n        const pixels = hdrInfo.width * hdrInfo.height;\n        const pixelsDataRGBA32 = new Float32Array(pixels * 4);\n        for (let i = 0; i < pixels; i += 1) {\n            pixelsDataRGBA32[i * 4] = pixelsDataRGB32[i * 3];\n            pixelsDataRGBA32[i * 4 + 1] = pixelsDataRGB32[i * 3 + 1];\n            pixelsDataRGBA32[i * 4 + 2] = pixelsDataRGB32[i * 3 + 2];\n            pixelsDataRGBA32[i * 4 + 3] = 1;\n        }\n        callback(hdrInfo.width, hdrInfo.height, texture.generateMipMaps, false, () => {\n            const engine = texture.getEngine();\n            texture.type = 1;\n            texture.format = 5;\n            texture._gammaSpace = false;\n            engine._uploadDataToTextureDirectly(texture, pixelsDataRGBA32);\n        });\n    }\n}\n//# sourceMappingURL=hdrTextureLoader.js.map"],"names":["ldexp","mantissa","exponent","rgbe2float","float32array","red","green","blue","index","readStringLine","uint8array","startIndex","line","character","i","RGBE_ReadHeader","height","width","endOfHeader","findFormat","lineIndex","match","RGBE_ReadPixels","hdrInfo","readRGBEPixelsRLE","num_scanlines","scanline_width","a","b","c","d","count","dataIndex","endIndex","scanLineArrayBuffer","scanLineArray","resultBuffer","resultArray","readRGBEPixelsNotRLE","j","_HDRTextureLoader","data","texture","callback","pixelsDataRGB32","pixels","pixelsDataRGBA32","engine"],"mappings":"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","x_google_ignoreList":[0,1]}